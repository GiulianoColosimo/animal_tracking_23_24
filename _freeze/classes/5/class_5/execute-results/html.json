{
  "hash": "0818918f15b38c9e0ca81e07d82cacaf",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Animal tracking nella biologia della conservazione\"\nsubtitle: \"Class 5\"\ndate: \"2024-05-23\"\nfooter:  \"[Animal tracking nella biologia della conservazione - Giuliano Colosimo, PhD](https://giulianocolosimo.github.io/animal_tracking_23_24/)\"\nlogo: ../../figures/Tor-Vergata_logo_cmyk.png\nformat: \n  revealjs:\n    width: 1600\n    height: 900\n    theme: slides.scss\n    multiplex: true\n    transition: fade\n    slide-number: true\n    chalkboard: \n      boardmarker-width: 5\neditor: visual\nfrom: markdown+emoji\nexecute:\n  freeze: auto\neditor_options: \n  chunk_output_type: console\nbibliography: /Users/giulianocolosimo/Library/CloudStorage/ProtonDrive-giuliano.colosimo@protonmail.com/manuscripts/literature/bibtex/comprehensive_database.bib\ncsl: /Users/giulianocolosimo/Library/CloudStorage/ProtonDrive-giuliano.colosimo@protonmail.com/manuscripts/literature/bibtex/apa_5th_edition.csl\ncitation_package: biblatex\ncitecolor: \"red\"\n---\n\n\n\n\n::: columns\n::: {.column width=\"50%\"}\n1.  [Setting up your computers]{style=\"color: green;\"}\n    -   [Packages to install]{style=\"color: green;\"}\n2.  [An introduction to Animal tracking]{style=\"color: green;\"}\n    -   [Tagging systems]{style=\"color: green;\"}\n3.  [CRS]{style=\"color: green;\"}\n    -   [Telemetry and GPS]{style=\"color: green;\"}\n4.  [Movement Data]{style=\"color: green;\"}\n5.  [On-line databases]{style=\"color: green;\"}\n    -   [GBIF]{style=\"color: green;\"}\n    -   [Movebank]{style=\"color: green;\"}\n:::\n\n::: {.column width=\"50%\"}\n6.  [Drivers of species distribution]{style=\"color: green;\"}\n7.  [Home range estimates]{style=\"color: orange;\"}\n    -   [MPC]{style=\"color: orange;\"}\n    -   [KDE]{style=\"color: orange;\"}\n    -   [Kriging]{style=\"color: orange;\"}\n    -   [BBM]{style=\"color: orange;\"}\n8.  [Species distribution modeling]{style=\"color: GhostWhite;\"}\n    -   [Resource selection functions]{style=\"color: GhostWhite;\"}\n    -   [Step selection functions]{style=\"color: GhostWhite;\"}\n9.  [Modeling approaches]{style=\"color: GhostWhite;\"}\n:::\n:::\n\n## What is a home range?\n\n- Home range estimators are widely used in spatial ecology studies, as they provide basic measurements of animal space-use patterns\n\n. . .\n\n> Home range estimators are a critical component for understanding animal spatial ecology. The choice of home range estimator in spatial ecology studies can significantly influence management and conservation actions, as different methods lead to vastly different inter- pretations of movement patterns, habitat selection, as well as home range requirements [@Silva2018]\n\n\n## What is a home range?\n\n- The geography area to which an organism normally confines its activities\n\n. . .\n\n- The extent of space animals use to live and reproduce [@Viana2018]\n\n- Home range is defined by the interaction between animals and the environment, and its size is the direct result of movement driven by habitat selection and other external factors, biotic interactions, and intrinsic factors related to individual state and characteristics [@Borger2008]\n\n- Home range formation is thus the result of dynamic processes. Both the habitat and internal state of animals might change through time and cause home range size to vary [@Viana2018]\n\n. . .\n\n- How can we estimate home-range?\n\n## Estimates of home-range\n\n- Minimum Convex Polygon\n    - The simplest way to draw the boundaries of a home range from a set of location data is to construct the smallest possible convex polygon around the data\n- Kernel Density Estimators\n    - Extrapolate where a geo-tracked animal spends its time\n- Kriging\n    - Spatial prediction based on a geostatistical model [@Webster2007]\n- Brownian Bridge Movements\n    -  Explicitly models an animalâ€™s movement path and estimates an animal mobility feature called Brownian motion variance\n\n## Estimation using MCP\n\n- We will be working with the bat databases that you should already have downloaded\n- In case you need it again you can find it [here](https://drive.proton.me/urls/JKGD8SYASR#qYRvkKaVjr10)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(move)\nlibrary(adehabitatHR)\nlibrary(scales)\nbats <- move(\"PATH/TO_YOUR/FILE/Parti-colored bat Safi Switzerland.csv\")\nX330 <- bats[[\"X330\"]]\nX330$id <- \"X330\"\nmcpX330<-mcp(as(X330[,'id'], 'SpatialPointsDataFrame'))\nplot(X330, type=\"n\", bty=\"na\", xlab=\"Longitude\", ylab=\"Latitude\")\nplot(mcpX330, col=\"grey90\", lty=2, lwd=1.25, add=TRUE)\npoints(X330, pch=16)\npoints(X330, pch=1, col=\"white\")\nlegend(\"topright\", as.character(\"95% MCP\"), fill=\"grey90\", bty=\"n\")\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n## Estimation using MCP\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](class_5_files/figure-revealjs/unnamed-chunk-3-1.png){width=960}\n:::\n:::\n\n\n## Estimation using MCP\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmcpX330\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nObject of class \"SpatialPolygonsDataFrame\" (package sp):\n\nNumber of SpatialPolygons:  1\n\nVariables measured:\n       id         area\nX330 X330 7.053224e-07\n```\n\n\n:::\n:::\n\n\n. . .\n\n- Area value seems strange. That is because our used locations are in the geographic coordinates system (long/lat)  \n- *adehabitatHR* calculated the area according to the units of the projection, in this case decimal degrees\n- Therefore we have to project our data into a equidistant projection\n\n## Estimation using MCP\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbats$id <- trackId(bats) \nmcpData<-mcp(as(bats[,'id'],'SpatialPointsDataFrame'))\nbats.proj <- spTransform(bats, CRS(\"+proj=somerc +lat_0=46.95240555555556 +lon_0=7.439583333333333 +x_0=600000 +y_0=200000 +ellps=bessel +units=m +no_defs\"))\nmcpData.proj <- mcp(as(bats.proj[, 'id'],'SpatialPointsDataFrame'))\nmcpData.proj\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nObject of class \"SpatialPolygonsDataFrame\" (package sp):\n\nNumber of SpatialPolygons:  17\n\nVariables measured:\n       id      area\nX21   X21  5107.168\nX42   X42  5633.081\nX127 X127  8385.456\nX146 X146  9285.353\nX168 X168 11898.905\nX191 X191  2577.603\n...\n```\n\n\n:::\n:::\n\n\n## Estimation using MCP\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(bats.proj[[\"X21\"]], bty=\"na\", xlab=\"Longitude\", ylab=\"Latitude\")\nplot(mcpData.proj[mcpData.proj$id==\"X21\",], add=TRUE)\nlegend(\"bottomleft\", c(\"First reproject then mcp\"), lty=1, bty=\"n\")\n```\n\n::: {.cell-output-display}\n![](class_5_files/figure-revealjs/unnamed-chunk-6-1.png){width=960}\n:::\n:::\n\n\n## Size of MCP changes with sampling effort \n\n\n::: {.cell}\n\n```{.r .cell-code}\nhrBootstrap(bats[['X21']], rep=500, levelMax=95)\nlegend(\"bottomright\", \nlegend=c(\"real MCP size\",\"100% percentil\",\"75% percentil\",\"50% percentil\",\"25% percentil\",\"0% percentil\"), \nlty=c(4,2,3,1,3,2), col=c(\"black\",\"cyan\",\"red\",\"black\",\"red\",\"cyan\"))\n```\n:::\n\n\n![Bootstrap of MCP](./mcpbootstrap.png)\n\n## MCP using a KDE\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemplate <- raster(extent(bats.proj[[1]]))\nres(template)<-500\ncount <- rasterize(split(bats.proj)[[1]], template,field=1,  fun=\"count\")\nplot(count, col=grey(10:0/12))\nplot(mcpData.proj[1,], add=TRUE)\npoints(bats.proj[[1]], pch=16, cex=0.5)\n```\n\n::: {.cell-output-display}\n![](class_5_files/figure-revealjs/unnamed-chunk-8-1.png){width=960}\n:::\n:::\n\n\n## MCP using a KDE\n\n- h: degree of smoothness or how tightly the data should be hugged by the distribution function\n- h=\"LSCV\": h calculated from the data via least square cross validation\n- h=\"ad-hoc\": h calculated from the data via sample size and spatial spread\n\n\n::: {.cell}\n\n```{.r .cell-code}\nX21 <- bats.proj[['X21']]\nkern1 <- kernelUD(as(X21, \"SpatialPoints\"), h=500)\nkern2 <- kernelUD(as(X21, \"SpatialPoints\"))\nkern3 <- kernelUD(as(X21, \"SpatialPoints\"), h=2000)\nkern4 <- kernelUD(as(X21, \"SpatialPoints\"), h=\"LSCV\")\nkern <- c(\"kern1\", \"kern2\", \"kern3\", \"kern4\")\nhName <- c(\"h=500\",\n           \"h='ad-hoc'\",\n           \"h=2000\",\n           \"h=LSCV\")\n```\n:::\n\n\n## MCP using a KDE\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow=c(2,2))\npar(mar=c(1,0.5,3,0.5))\nfor(i in 1:4){\n  plot(getverticeshr(get(kern[i])))\n  points(X21, pch=16, cex=0.75, col=alpha(\"black\", 0.2))\n  points(X21, cex=0.75)\n  title(hName[i])\n}\n```\n\n::: {.cell-output-display}\n![](class_5_files/figure-revealjs/unnamed-chunk-10-1.png){width=960}\n:::\n:::\n\n\n\n## References",
    "supporting": [
      "class_5_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}